package com.github.bloowper.schedulerclient.integration;

import com.github.bloowper.schedulerclient.DummyNotificationDto;
import com.github.bloowper.schedulerclient.api.JobDescription;
import com.github.bloowper.schedulerclient.api.JobId;
import com.github.bloowper.schedulerclient.api.JobScheduler;
import com.github.bloowper.schedulerclient.api.Schedule;
import com.github.bloowper.schedulerclient.common.TestStopper;
import lombok.SneakyThrows;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.annotation.DirtiesContext;

import java.time.Duration;
import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;
import static org.awaitility.Awaitility.await;


class SchedulingExecutionIT extends IntegrationTestBase {
    private static final Duration ALLOWED_DIFFERENCE = Duration.ofMillis(950);
    // Uses default JonExecutionNotifier
    @Autowired
    private JobScheduler jobScheduler;
    @Autowired
    JobExecutionListener jobExecutionListener;

    // TODO: better handling of job execution listener then @DirtyContext
    @Test
    @SneakyThrows
    void fixedJobShouldBeExecuted() {
        // Given
        TestStopper stopper = TestStopper.start();
        Duration delay = Duration.ofSeconds(30);
        DummyNotificationDto dummyNotificationDto = new DummyNotificationDto("fixed job should not be called before execution date");
        JobDescription jobDescription = new JobDescription(
                dummyNotificationDto,
                Schedule.fixed(stopper.getStart().plus(delay))
        );

        // When
        JobId jobId = jobScheduler.scheduleJob(jobDescription);

        // Then
        await().atMost(delay).until(() -> jobExecutionListener.wasExecutedWith(dummyNotificationDto,1));
        stopper.stop();
        Duration elapsedTime = stopper.getElapsedTime();
        assertThat(elapsedTime).isCloseTo(delay, ALLOWED_DIFFERENCE);
    }


    @Test
    @DirtiesContext
    void createCronJobAndAwaitForExecution() {
        // Given
        DummyNotificationDto notificationDto = new DummyNotificationDto("dummyValue3");

        JobId id = JobId.autoGenerated();
        JobDescription jobDescription = new JobDescription(
                id,
                notificationDto,
                Schedule.cron("*/4 * * * * *")
        );

        // When
        jobScheduler.scheduleJob(jobDescription);

        // Then
        await().atMost(Duration.ofSeconds(30)).until(() -> jobExecutionListener.wasExecutedWith(notificationDto,1));
    }

    @Test
    @DirtiesContext
    void createIntervalJobAndAwaitForExecutions() {
        // Given
        DummyNotificationDto notificationDto = new DummyNotificationDto("interval job execution test");

        JobId id = JobId.autoGenerated();
        JobDescription jobDescription = new JobDescription(
                id,
                notificationDto,
                Schedule.interval(Duration.ofSeconds(3))
        );

        // When
        jobScheduler.scheduleJob(jobDescription);

        // Then
        await().atMost(Duration.ofSeconds(30)).until(() -> jobExecutionListener.wasExecutedWith(notificationDto,2));
    }

    @Test
    void createIntervalJobWithDelayAndAwaitForExecution(){
        // Given
        TestStopper stopper = TestStopper.start();
        Instant now = stopper.getStart();
        Duration interval = Duration.ofSeconds(1);
        Duration delay = Duration.ofSeconds(10);
        DummyNotificationDto notificationDto = new DummyNotificationDto("job that should be called every second after given instant");
        Schedule.Interval schedule = Schedule.interval(interval).startAfter(now.plus(delay)); // Job that run every 1 second but after 10-second delay
        JobDescription jobDescription = new JobDescription(notificationDto, schedule);

        // When
        jobScheduler.scheduleJob(jobDescription);

        // Then
        await().atMost(delay).until(() -> jobExecutionListener.wasExecutedWith(notificationDto));
        Duration elapsedTime = stopper.stop().getElapsedTime();
        assertThat(elapsedTime).isCloseTo(delay, ALLOWED_DIFFERENCE);
    }
}
